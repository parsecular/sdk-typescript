/**
 * Hand-written WebSocket client for real-time orderbook and trade streaming.
 *
 * Provides a stateful local orderbook that applies snapshots + deltas
 * so consumers always get a materialized book. Handles auth, reconnect
 * with exponential backoff, resubscribe, sequence gap detection, and resync.
 *
 * NOT generated by Stainless — this file lives on the `next` branch and
 * persists across SDK regenerations.
 */

import WebSocket from 'isomorphic-ws';

// ── Public types ────────────────────────────────────────────

export interface StreamingOrderbookLevel {
  price: number;
  size: number;
}

export type FeedState = 'healthy' | 'degraded' | 'disconnected';
export type BookState = 'fresh' | 'stale' | 'needs_refresh';
export type OrderbookKind = 'snapshot' | 'delta';

export interface OrderbookSnapshot {
  parsecId: string;
  outcome: string;
  exchange: string;
  tokenId: string;
  marketId: string;
  bids: StreamingOrderbookLevel[];
  asks: StreamingOrderbookLevel[];
  midPrice: number;
  spread: number;
  tickSize?: number | undefined;
  kind: OrderbookKind;
  serverSeq: number;
  feedState: FeedState;
  bookState: BookState;
  staleAfterMs: number;
  exchangeTsMs?: number | undefined;
  ingestTsMs?: number | undefined;
}

export interface Activity {
  parsecId: string;
  outcome: string;
  exchange: string;
  tokenId: string;
  marketId: string;
  kind: 'trade' | 'fill';
  price: number;
  size: number;
  side?: string | undefined;
  aggressorSide?: string | undefined;
  tradeId?: string | undefined;
  fillId?: string | undefined;
  orderId?: string | undefined;
  serverSeq: number;
  feedState: string;
  exchangeTsMs?: number | undefined;
  ingestTsMs?: number | undefined;
  sourceChannel: string;
}

export interface WsError {
  code?: number | undefined;
  message: string;
  parsecId?: string | undefined;
}

export interface MarketSubscription {
  parsecId: string;
  outcome?: string | undefined;
  depth?: number | undefined;
}

export interface ParsecWebSocketOptions {
  /** Override WebSocket URL. Derived from client baseURL if omitted. */
  url?: string | undefined;
}

// ── Event map ───────────────────────────────────────────────

export interface ParsecWebSocketEventMap {
  orderbook: (book: OrderbookSnapshot) => void;
  activity: (activity: Activity) => void;
  error: (err: WsError) => void;
  connected: () => void;
  disconnected: (reason: string) => void;
  reconnecting: (attempt: number, delayMs: number) => void;
  slow_reader: (parsecId: string, outcome: string) => void;
  heartbeat: (tsMs: number) => void;
}

type EventName = keyof ParsecWebSocketEventMap;

// ── Internal types ──────────────────────────────────────────

interface LocalBook {
  parsecId: string;
  outcome: string;
  exchange: string;
  tokenId: string;
  marketId: string;
  bids: StreamingOrderbookLevel[];
  asks: StreamingOrderbookLevel[];
  tickSize?: number | undefined;
  lastSeq: number;
}

type WsState = 'disconnected' | 'connecting' | 'authenticating' | 'connected' | 'reconnecting' | 'closed';

const PRICE_EPSILON = 1e-9;
const MAX_RECONNECT_DELAY_MS = 30_000;
const BASE_RECONNECT_DELAY_MS = 1_000;

// ── Helpers ─────────────────────────────────────────────────

function computeMidSpread(
  bids: StreamingOrderbookLevel[],
  asks: StreamingOrderbookLevel[],
): { midPrice: number; spread: number } {
  const bestBid = bids.length > 0 ? bids[0]!.price : 0;
  const bestAsk = asks.length > 0 ? asks[0]!.price : 0;
  const midPrice = bestBid > 0 && bestAsk > 0 ? (bestBid + bestAsk) / 2 : bestBid || bestAsk;
  const spread = bestBid > 0 && bestAsk > 0 ? Math.abs(bestAsk - bestBid) : 0;
  return { midPrice, spread };
}

function parseWireLevels(raw: unknown): StreamingOrderbookLevel[] {
  if (!Array.isArray(raw)) return [];
  const levels: StreamingOrderbookLevel[] = [];
  for (const item of raw) {
    if (
      Array.isArray(item) &&
      item.length >= 2 &&
      typeof item[0] === 'number' &&
      typeof item[1] === 'number'
    ) {
      levels.push({ price: item[0], size: item[1] });
    }
  }
  return levels;
}

function marketKey(parsecId: string, outcome: string): string {
  return `${parsecId}:${outcome}`;
}

function subKey(parsecId: string, outcome?: string): string {
  return outcome ? `${parsecId}:${outcome}` : parsecId;
}

// ── WebSocket client ────────────────────────────────────────

export class ParsecWebSocket {
  private readonly apiKey: string;
  private readonly wsUrl: string;

  private ws: WebSocket | null = null;
  private state: WsState = 'disconnected';
  private intentionalClose = false;
  private reconnectAttempt = 0;
  private reconnectTimer: ReturnType<typeof setTimeout> | null = null;

  private readonly subscriptions = new Map<string, MarketSubscription>();
  private readonly books = new Map<string, LocalBook>();
  private readonly listeners = new Map<EventName, Set<(...args: any[]) => void>>();

  /** @internal — called by ParsecAPI.ws(), not directly by users. */
  constructor(apiKey: string, wsUrl: string) {
    this.apiKey = apiKey;
    this.wsUrl = wsUrl;
  }

  // ── Event emitter ───────────────────────────────────────

  on<E extends EventName>(event: E, listener: ParsecWebSocketEventMap[E]): this {
    let set = this.listeners.get(event);
    if (!set) {
      set = new Set();
      this.listeners.set(event, set);
    }
    set.add(listener as (...args: any[]) => void);
    return this;
  }

  off<E extends EventName>(event: E, listener: ParsecWebSocketEventMap[E]): this {
    const set = this.listeners.get(event);
    if (set) {
      set.delete(listener as (...args: any[]) => void);
    }
    return this;
  }

  private emit<E extends EventName>(event: E, ...args: Parameters<ParsecWebSocketEventMap[E]>): void {
    const set = this.listeners.get(event);
    if (!set) return;
    for (const fn of set) {
      try {
        fn(...args);
      } catch {
        // Swallow listener errors to prevent one bad handler from killing the stream.
      }
    }
  }

  // ── Connection lifecycle ────────────────────────────────

  async connect(): Promise<void> {
    if (this.state === 'connected' || this.state === 'connecting' || this.state === 'authenticating') {
      return;
    }

    this.intentionalClose = false;
    this.reconnectAttempt = 0;

    return new Promise<void>((resolve, reject) => {
      this.doConnect(resolve, reject);
    });
  }

  close(): void {
    this.intentionalClose = true;
    this.state = 'closed';

    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    this.subscriptions.clear();
    this.books.clear();

    if (this.ws) {
      this.ws.onclose = null;
      this.ws.onerror = null;
      this.ws.onmessage = null;
      this.ws.onopen = null;
      this.ws.close();
      this.ws = null;
    }

    this.emit('disconnected', 'Client closed');
  }

  // ── Subscribe / unsubscribe ─────────────────────────────

  subscribe(markets: MarketSubscription | MarketSubscription[]): void {
    const arr = Array.isArray(markets) ? markets : [markets];
    const toSend: MarketSubscription[] = [];

    for (const m of arr) {
      const key = subKey(m.parsecId, m.outcome);
      if (!this.subscriptions.has(key)) {
        this.subscriptions.set(key, m);
        toSend.push(m);
      }
    }

    if (toSend.length > 0 && this.state === 'connected') {
      this.wsSend({
        type: 'subscribe',
        markets: toSend.map((m) => ({
          parsec_id: m.parsecId,
          outcome: m.outcome,
          depth: m.depth,
        })),
      });
    }
  }

  unsubscribe(markets: MarketSubscription | MarketSubscription[]): void {
    const arr = Array.isArray(markets) ? markets : [markets];
    const toSend: MarketSubscription[] = [];

    for (const m of arr) {
      const key = subKey(m.parsecId, m.outcome);
      if (this.subscriptions.has(key)) {
        this.subscriptions.delete(key);
        toSend.push(m);

        // Clean up local books
        if (m.outcome) {
          this.books.delete(marketKey(m.parsecId, m.outcome));
        } else {
          for (const k of this.books.keys()) {
            if (k.startsWith(`${m.parsecId}:`)) {
              this.books.delete(k);
            }
          }
        }
      }
    }

    if (toSend.length > 0 && this.state === 'connected') {
      this.wsSend({
        type: 'unsubscribe',
        markets: toSend.map((m) => ({
          parsec_id: m.parsecId,
          outcome: m.outcome,
        })),
      });
    }
  }

  // ── Internals ───────────────────────────────────────────

  private doConnect(onAuth?: (value: void) => void, onFail?: (reason: Error) => void): void {
    if (this.ws) {
      this.ws.onclose = null;
      this.ws.onerror = null;
      this.ws.onmessage = null;
      this.ws.onopen = null;
      this.ws.close();
      this.ws = null;
    }

    this.state = 'connecting';

    try {
      this.ws = new WebSocket(this.wsUrl);
    } catch (err) {
      this.emit('error', { message: err instanceof Error ? err.message : 'WS connect failed' });
      if (onFail) {
        onFail(err instanceof Error ? err : new Error(String(err)));
      } else {
        this.scheduleReconnect();
      }
      return;
    }

    this.ws.onopen = () => {
      this.state = 'authenticating';
      this.emit('connected');
      this.wsSend({ type: 'auth', api_key: this.apiKey });
    };

    this.ws.onmessage = (event: WebSocket.MessageEvent) => {
      try {
        const data = typeof event.data === 'string' ? event.data : String(event.data);
        const msg = JSON.parse(data);
        this.handleServerMessage(msg, onAuth, onFail);
      } catch {
        // Ignore parse errors
      }
    };

    this.ws.onclose = (event: WebSocket.CloseEvent) => {
      this.ws = null;
      const wasAuthenticating = this.state === 'authenticating';
      this.state = 'disconnected';

      this.emit('disconnected', event.reason || 'Connection closed');

      if (this.intentionalClose) return;

      // If we were waiting for auth and got disconnected, reject the connect() promise
      if (wasAuthenticating && onFail) {
        onFail(new Error('Connection closed during authentication'));
        return;
      }

      this.scheduleReconnect();
    };

    this.ws.onerror = () => {
      this.emit('error', { message: 'WebSocket error' });
    };
  }

  private handleServerMessage(
    msg: any,
    onAuth?: (value: void) => void,
    onFail?: (reason: Error) => void,
  ): void {
    const type = msg.type;

    switch (type) {
      case 'auth_ok': {
        this.state = 'connected';
        this.reconnectAttempt = 0;

        // Clear one-shot connect() callbacks so reconnects don't re-resolve
        if (onAuth) {
          onAuth();
          // Null out the callbacks — they're consumed now. We re-bind fresh
          // message handler without callbacks on reconnect.
          this.rebindMessageHandler();
        }

        this.resubscribeAll();
        break;
      }

      case 'auth_error': {
        const errMsg = msg.message ?? 'Authentication failed';
        this.emit('error', { code: msg.code, message: errMsg });

        // Auth errors are fatal — do NOT reconnect. Bad key won't get better.
        this.intentionalClose = true;
        this.state = 'closed';

        if (this.ws) {
          this.ws.onclose = null;
          this.ws.close();
          this.ws = null;
        }

        if (onFail) {
          onFail(new Error(errMsg));
        }
        break;
      }

      case 'orderbook': {
        this.handleOrderbookSnapshot(msg);
        break;
      }

      case 'orderbook_delta': {
        this.handleOrderbookDelta(msg);
        break;
      }

      case 'activity': {
        this.emit('activity', {
          parsecId: msg.parsec_id ?? '',
          outcome: msg.outcome ?? '',
          exchange: msg.exchange ?? '',
          tokenId: msg.token_id ?? '',
          marketId: msg.market_id ?? '',
          kind: msg.kind ?? 'trade',
          price: msg.price ?? 0,
          size: msg.size ?? 0,
          side: msg.side,
          aggressorSide: msg.aggressor_side,
          tradeId: msg.trade_id,
          fillId: msg.fill_id,
          orderId: msg.order_id,
          serverSeq: msg.server_seq ?? 0,
          feedState: msg.feed_state ?? 'healthy',
          exchangeTsMs: msg.exchange_ts_ms,
          ingestTsMs: msg.ingest_ts_ms,
          sourceChannel: msg.source_channel ?? '',
        });
        break;
      }

      case 'heartbeat': {
        this.emit('heartbeat', msg.ts_ms ?? Date.now());
        break;
      }

      case 'resync_required': {
        const parsecId = msg.parsec_id ?? '';
        const outcome = msg.outcome;
        this.wsSend({ type: 'resync', parsec_id: parsecId, outcome });
        break;
      }

      case 'slow_reader': {
        this.emit('slow_reader', msg.parsec_id ?? '', msg.outcome ?? '');
        break;
      }

      case 'error': {
        this.emit('error', {
          code: msg.code,
          message: msg.message ?? 'Server error',
          parsecId: msg.parsec_id,
        });
        break;
      }
    }
  }

  private handleOrderbookSnapshot(msg: any): void {
    const parsecId: string = msg.parsec_id ?? '';
    const outcome: string = msg.outcome ?? '';
    const exchange: string = msg.exchange ?? '';
    const tokenId: string = msg.token_id ?? '';
    const marketId: string = msg.market_id ?? '';

    const bids = parseWireLevels(msg.bids);
    const asks = parseWireLevels(msg.asks);

    // Wire format is [[price, size], ...] — already parsed to objects above.
    // Sort: bids descending, asks ascending.
    bids.sort((a, b) => b.price - a.price);
    asks.sort((a, b) => a.price - b.price);

    const key = marketKey(parsecId, outcome);
    const seq: number = msg.server_seq ?? 0;

    this.books.set(key, {
      parsecId,
      outcome,
      exchange,
      tokenId,
      marketId,
      bids,
      asks,
      tickSize: msg.tick_size,
      lastSeq: seq,
    });

    const { midPrice, spread } = computeMidSpread(bids, asks);

    this.emit('orderbook', {
      parsecId,
      outcome,
      exchange,
      tokenId,
      marketId,
      bids,
      asks,
      midPrice,
      spread,
      tickSize: msg.tick_size,
      kind: 'snapshot',
      serverSeq: seq,
      feedState: msg.feed_state ?? 'healthy',
      bookState: msg.book_state ?? 'fresh',
      staleAfterMs: msg.stale_after_ms ?? 0,
      exchangeTsMs: msg.exchange_ts_ms,
      ingestTsMs: msg.ingest_ts_ms,
    });
  }

  private handleOrderbookDelta(msg: any): void {
    const parsecId: string = msg.parsec_id ?? '';
    const outcome: string = msg.outcome ?? '';
    const key = marketKey(parsecId, outcome);
    const book = this.books.get(key);

    // Delta before first snapshot — ignore.
    if (!book) return;

    const seq: number = msg.server_seq ?? 0;

    // Sequence gap detection: if seq is not exactly lastSeq + 1, request resync.
    if (book.lastSeq > 0 && seq !== book.lastSeq + 1) {
      this.wsSend({ type: 'resync', parsec_id: parsecId, outcome });
      return;
    }

    book.lastSeq = seq;

    // Apply absolute replacement semantics.
    const changes: Array<{ side: string; price: number; size: number }> = msg.changes ?? [];
    for (const ch of changes) {
      if (typeof ch.price !== 'number' || typeof ch.size !== 'number') continue;
      const levels = ch.side === 'bid' ? book.bids : book.asks;

      if (ch.size <= 0) {
        // Remove level
        const idx = levels.findIndex((l) => Math.abs(l.price - ch.price) < PRICE_EPSILON);
        if (idx !== -1) levels.splice(idx, 1);
        continue;
      }

      // Set / update level
      const idx = levels.findIndex((l) => Math.abs(l.price - ch.price) < PRICE_EPSILON);
      if (idx !== -1) {
        levels[idx] = { price: ch.price, size: ch.size };
        continue;
      }

      // Insert while preserving sort (bids desc, asks asc)
      const insertAt =
        ch.side === 'bid' ?
          levels.findIndex((l) => l.price < ch.price)
        : levels.findIndex((l) => l.price > ch.price);

      if (insertAt === -1) {
        levels.push({ price: ch.price, size: ch.size });
      } else {
        levels.splice(insertAt, 0, { price: ch.price, size: ch.size });
      }
    }

    // Re-sort to handle any edge cases.
    book.bids.sort((a, b) => b.price - a.price);
    book.asks.sort((a, b) => a.price - b.price);

    const { midPrice, spread } = computeMidSpread(book.bids, book.asks);

    this.emit('orderbook', {
      parsecId: book.parsecId,
      outcome: book.outcome,
      exchange: book.exchange,
      tokenId: book.tokenId,
      marketId: book.marketId,
      bids: book.bids,
      asks: book.asks,
      midPrice,
      spread,
      tickSize: book.tickSize,
      kind: 'delta',
      serverSeq: seq,
      feedState: msg.feed_state ?? 'healthy',
      bookState: msg.book_state ?? 'fresh',
      staleAfterMs: msg.stale_after_ms ?? 0,
      exchangeTsMs: msg.exchange_ts_ms,
      ingestTsMs: msg.ingest_ts_ms,
    });
  }

  // ── Reconnect ───────────────────────────────────────────

  private scheduleReconnect(): void {
    if (this.intentionalClose) return;

    this.state = 'reconnecting';
    this.reconnectAttempt++;

    const delayMs = Math.min(
      BASE_RECONNECT_DELAY_MS * Math.pow(2, this.reconnectAttempt - 1),
      MAX_RECONNECT_DELAY_MS,
    );

    this.emit('reconnecting', this.reconnectAttempt, delayMs);

    this.reconnectTimer = setTimeout(() => {
      this.reconnectTimer = null;
      if (this.intentionalClose) return;
      this.doConnect();
    }, delayMs);
  }

  private resubscribeAll(): void {
    if (this.subscriptions.size === 0) return;
    const markets = Array.from(this.subscriptions.values()).map((m) => ({
      parsec_id: m.parsecId,
      outcome: m.outcome,
      depth: m.depth,
    }));
    this.wsSend({ type: 'subscribe', markets });
  }

  /** Rebind the message handler WITHOUT the one-shot connect() callbacks. */
  private rebindMessageHandler(): void {
    if (!this.ws) return;
    this.ws.onmessage = (event: WebSocket.MessageEvent) => {
      try {
        const data = typeof event.data === 'string' ? event.data : String(event.data);
        const msg = JSON.parse(data);
        this.handleServerMessage(msg);
      } catch {
        // Ignore parse errors
      }
    };
  }

  private wsSend(msg: unknown): void {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(msg));
    }
  }
}
